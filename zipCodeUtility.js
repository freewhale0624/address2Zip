// Generated by CoffeeScript 1.6.3
(function() {
  var fs, setScopeEle, zipUtility;

  fs = require('fs');

  zipUtility = require('./zipCodeUtility');

  /*
  log = ''
  logError = ''
  logEle = ''
  */


  /*
  將郵局資料insert入DB時,將X之X號轉換為X.X號入DB
  scope = 郵局資料中scope資料
  */


  exports.convertScopeDashToPoint = function(scope) {
    var dashInt, dashPoint, regex;
    if (!scope.match('之')) {
      return scope;
    }
    regex = [/\d+之\d+至之\d+號/, /\d+之\d+[號巷]/];
    if (regex[0].test(scope)) {
      dashInt = /\d+之/.exec(scope).toString().replace(/[^\d]/g, '');
      dashPoint = /之\d+至/.exec(scope).toString().replace(/[^\d]/g, '');
      scope = scope.replace(/之\d+至/, (dashPoint / 1000 + '號至').slice(1));
      dashPoint = /至之\d+號/.exec(scope).toString().replace(/[^\d]/g, '');
      scope = scope.replace(/之\d+/, dashInt + (dashPoint / 1000).toString().slice(1));
    } else {
      while (regex[1].test(scope)) {
        dashPoint = /之\d+[號巷]/.exec(scope).toString().replace(/[^\d]/g, '');
        scope = scope.replace(/之\d+/, (dashPoint / 1000).toString().slice(1));
      }
    }
    return scope;
  };

  /*
  將郵局資料insert入DB時,將scope分為lane,alley,no,floor.
  每種又分為[單雙連全],最大值,最小值
  scope = 郵局資料中scope資料
  number = 第n筆資料
  */


  exports.decomposeScope = function(scope, number) {
    var i, num, regex, scopeArrayName, scopeEle, scopeEleMaxNum, scopeEleMinNum, scopeEleNum, scopePartA, scopePartB, scopePartC, tmpOdevity;
    num = 0;
    scopeArrayName = ['巷', '弄', '號', '樓'];
    scopeEle = new Array();
    i = 0;
    while (i < 4) {
      scopeEle[i] = new Array();
      scopeEle[i][0] = scopeEle[i][1] = scopeEle[i][2] = '';
      i++;
    }
    scope = this.convertScopeDashToPoint(scope);
    regex = [/[單雙連].+至.*以[上下]$/, /至.*以[上下]$/, /[單雙連].+至/, /^[\d\.巷弄號樓]+至/, /[單雙連].*以[上下]$/, /.*樓以[上下]$/, /^[\d\.巷弄號樓]+[全單雙][全]?$/, /^[\d\.巷弄號樓]+$/, /^[全單雙][全]?$/, /號及以上附號/, /附號/, /號\(.*\)/];
    i = 0;
    while (i < regex.length) {
      if (regex[i].test(scope)) {
        num = i + 1;
        break;
      }
      i++;
    }
    switch (num) {
      case 1:
      case 3:
        tmpOdevity = scopeEleMinNum = scopeEleMaxNum = void 0;
        if (/^[\d\.巷弄號樓]+/.test(scope)) {
          scopePartA = /^[\d\.巷弄號樓]+/.exec(scope)[0].toString();
          scope = scope.slice(scopePartA.length);
          setScopeEle(scopePartA, scopeArrayName, scopeEle, 'setBoth', function(scopeEleVal, odevityVal, scopeEleNumVal) {
            return scopeEle = scopeEleVal;
          });
        }
        scopePartB = /^[單雙連]\d+\.?\d*\D至/.exec(scope)[0].toString();
        scope = scope.slice(scopePartB.length);
        setScopeEle(scopePartB, scopeArrayName, scopeEle, 'setMin', function(scopeEleVal, odevityVal, scopeEleNumVal) {
          scopeEle = scopeEleVal;
          tmpOdevity = odevityVal;
          return scopeEleMinNum = scopeEleNumVal;
        });
        scopePartC = /^\d+\.?\d*[巷弄號樓](含附號)?/.exec(scope)[0].toString();
        scope = scope.slice(scopePartC.length);
        setScopeEle(scopePartC, scopeArrayName, scopeEle, 'setMax', function(scopeEleVal, odevityVal, scopeEleNumVal) {
          if (/含附號/.test(scopePartC)) {
            scopeEleVal[scopeEleNumVal][2] = scopeEleVal[scopeEleNumVal][2] + '.999';
          }
          scopeEle = scopeEleVal;
          return scopeEleMaxNum = scopeEleNumVal;
        });
        if (scopeEleMinNum < scopeEleMaxNum) {
          scopeEle[scopeEleMinNum][0] = tmpOdevity;
        } else {
          scopeEle[scopeEleMaxNum][0] = tmpOdevity;
        }
        break;
      case 2:
      case 4:
        if (/\d+至\d+樓$/.test(scope)) {
          scope = scope.replace('至', '樓至');
          scopePartA = /\d+\.?\d*號/.exec(scope)[0].toString();
          scope = scope.slice(scopePartA.length);
          setScopeEle(scopePartA, scopeArrayName, scopeEle, 'setBoth', function(scopeEleVal, odevityVal, scopeEleNumVal) {
            return scopeEle = scopeEleVal;
          });
        }
        scopePartB = /\d+\.?\d*\D至/.exec(scope)[0].toString();
        scope = scope.slice(scopePartB.length);
        setScopeEle(scopePartB, scopeArrayName, scopeEle, 'setMin', function(scopeEleVal, odevityVal, scopeEleNumVal) {
          scopeEleVal[scopeEleNumVal][0] = '連';
          return scopeEle = scopeEleVal;
        });
        scopePartC = /^\d+\.?\d*[巷弄號樓](含附號)?/.exec(scope)[0].toString();
        scope = scope.slice(scopePartC.length);
        setScopeEle(scopePartC, scopeArrayName, scopeEle, 'setMax', function(scopeEleVal, odevityVal, scopeEleNumVal) {
          return scopeEle = scopeEleVal;
        });
        break;
      case 5:
        if (/以[上下].*以[上下]/.test(scope)) {
          return null;
        }
        if (/^[\d\.巷弄號樓]+/.test(scope)) {
          scopePartA = /^[\d\.巷弄號樓]+/.exec(scope)[0].toString();
          scope = scope.slice(scopePartA.length);
          setScopeEle(scopePartA, scopeArrayName, scopeEle, 'setBoth', function(scopeEleVal, odevityVal, scopeEleNumVal) {
            return scopeEle = scopeEleVal;
          });
        }
        scopePartB = /^[單雙連].*以[上下]/.exec(scope)[0].toString();
        scope = scope.slice(scopePartB.length);
        if (/以下$/.test(scopePartB)) {
          setScopeEle(scopePartB, scopeArrayName, scopeEle, 'setMax', function(scopeEleVal, odevityVal, scopeEleNumVal) {
            if (/含附號/.test(scopePartB)) {
              scopeEleVal[scopeEleNumVal][2] = scopeEleVal[scopeEleNumVal][2] + '.999';
            }
            scopeEleVal[scopeEleNumVal][0] = odevityVal;
            return scopeEle = scopeEleVal;
          });
        } else if (/以上$/.test(scopePartB)) {
          setScopeEle(scopePartB, scopeArrayName, scopeEle, 'setMin', function(scopeEleVal, odevityVal, scopeEleNumVal) {
            scopeEleVal[scopeEleNumVal][0] = odevityVal;
            return scopeEle = scopeEleVal;
          });
        }
        break;
      case 6:
        if (/^[\d\.巷弄]+[號]/.test(scope)) {
          scopePartA = /^[\d\.巷弄]+[號]/.exec(scope)[0].toString();
          scope = scope.slice(scopePartA.length);
          setScopeEle(scopePartA, scopeArrayName, scopeEle, 'setBoth', function(scopeEleVal, odevityVal, scopeEleNumVal) {
            return scopeEle = scopeEleVal;
          });
        }
        scopePartB = /\d+樓以[上下]/.exec(scope)[0].toString();
        scope = scope.slice(scopePartB.length);
        if (/以下$/.test(scopePartB)) {
          setScopeEle(scopePartB, scopeArrayName, scopeEle, 'setMax', function(scopeEleVal, odevityVal, scopeEleNumVal) {
            scopeEleVal[scopeEleNumVal][0] = '連';
            if (/含附號/.test(scopePartB)) {
              scopeEleVal[scopeEleNumVal][2] = scopeEleVal[scopeEleNumVal][2] + '.999';
            }
            return scopeEle = scopeEleVal;
          });
        } else if (/以上$/.test(scopePartB)) {
          setScopeEle(scopePartB, scopeArrayName, scopeEle, 'setMin', function(scopeEleVal, odevityVal, scopeEleNumVal) {
            scopeEleVal[scopeEleNumVal][0] = '連';
            return scopeEle = scopeEleVal;
          });
        }
        break;
      case 7:
        scopeEleNum = void 0;
        scopePartA = /[\d\.巷弄號樓]+(含附號)?/.exec(scope)[0].toString();
        scope = scope.slice(scopePartA.length);
        setScopeEle(scopePartA, scopeArrayName, scopeEle, 'setBoth', function(scopeEleVal, odevityVal, scopeEleNumVal) {
          if (/含附號/.test(scopePartA)) {
            scopeEleVal[scopeEleNumVal][2] = scopeEleVal[scopeEleNumVal][2] + '.999';
          }
          scopeEleNum = scopeEleNumVal;
          return scopeEle = scopeEleVal;
        });
        scopePartB = /^[單雙全][全]?$/.exec(scope)[0].toString();
        scope = scope.slice(scopePartB.length);
        if (scopeEleNum < 3 && scopePartB.slice(0, 1) !== '全') {
          scopeEle[parseInt(scopeEleNum) + 1][0] = scopePartB.slice(0, 1);
        }
        break;
      case 8:
        scopePartA = /^[\d\.巷弄號樓]+$/.exec(scope)[0].toString();
        scope = scope.slice(scopePartA.length);
        setScopeEle(scopePartA, scopeArrayName, scopeEle, 'setBoth', function(scopeEleVal, odevityVal, scopeEleNumVal) {
          return scopeEle = scopeEleVal;
        });
        break;
      case 9:
        scopePartA = /^[全單雙][全]?/.exec(scope)[0].toString();
        scope = scope.slice(scopePartA.length);
        scopeEle[0][0] = scopePartA.slice(0, 1);
        break;
      case 10:
        scopePartA = /^\d+\.*\d+號及以上附號/.exec(scope)[0].toString();
        scope = scope.slice(scopePartA.length);
        setScopeEle(scopePartA, scopeArrayName, scopeEle, 'setMin', function(scopeEleVal, odevityVal, scopeEleNumVal) {
          scopeEleVal[scopeEleNumVal][0] = '連';
          scopeEleVal[scopeEleNumVal][2] = parseInt(scopeEleVal[scopeEleNumVal][1]) + '.999';
          return scopeEle = scopeEleVal;
        });
        break;
      case 11:
        if (/^\d+附號全$/.test(scope)) {
          scope = scope.replace('附號全', '號含附號');
        }
        scopePartA = /^[\d\.巷弄號]+含附號[全]?/.exec(scope)[0].toString();
        scope = scope.slice(scopePartA.length);
        setScopeEle(scopePartA, scopeArrayName, scopeEle, 'setMin', function(scopeEleVal, odevityVal, scopeEleNumVal) {
          scopeEleVal[scopeEleNumVal][0] = '連';
          scopeEleVal[scopeEleNumVal][2] = scopeEleVal[scopeEleNumVal][1] + '.999';
          return scopeEle = scopeEleVal;
        });
        break;
      case 12:
        scopePartA = /^\d+號\(.*\)/.exec(scope)[0].toString();
        scope = scope.slice(scopePartA.length);
        setScopeEle(scopePartA, scopeArrayName, scopeEle, 'setBoth', function(scopeEleVal, odevityVal, scopeEleNumVal) {
          return scopeEle = scopeEleVal;
        });
        break;
      default:
        return null;
    }
    return scopeEle;
  };

  /*
  將地址分解各個元素,有縣市,鄉鎮區,路,巷,弄,號,樓
  addr = 地址
  */


  exports.decomposeAddr = function(addr) {
    var addrElement, alley, area, city, dashVal, dashValThousandth, floor, i, lane, noNum, regex, road, scopeArrayName, scopeName, seperate;
    city = area = road = lane = alley = noNum = floor = '';
    regex = /^..[市縣]/;
    if (regex.test(addr)) {
      city = regex.exec(addr).toString();
      addr = addr.split(regex)[1];
    }
    regex = /^\D+市區|^\D+鎮區|^\D+鎮市|^\D區|^\D{2}[市鎮區鄉]|^\D{3}[區鄉島]/;
    if (regex.test(addr)) {
      area = regex.exec(addr).toString();
      addr = addr.split(regex)[1];
    }
    addr = zipUtility.numberFullToHalf(addr);
    addr = zipUtility.chineseToNum(addr);
    addr = zipUtility.trimAndReplaceDash(addr);
    regex = /^\D+/;
    if (regex.test(addr)) {
      road = regex.exec(addr).toString();
      addr = addr.split(regex)[1];
    }
    regex = /\D\d/;
    i = 0;
    while (!zipUtility.isMatchScopeRule(addr)) {
      if (regex.test(addr)) {
        seperate = addr.indexOf(regex.exec(addr).toString()) + 1;
        road = road + zipUtility.numberToChinese(addr.slice(0, seperate));
        addr = addr.slice(seperate);
      }
      i++;
      if (i === 5) {
        break;
      }
    }
    i = 0;
    scopeArrayName = ['巷', '弄', '號'];
    while (i < scopeArrayName.length) {
      scopeName = scopeArrayName[i];
      regex = new RegExp('^\\d+-\\d+' + scopeName);
      if (regex.test(addr)) {
        dashVal = addr.substring(addr.indexOf('-') + 1, addr.indexOf(scopeName));
        dashValThousandth = (dashVal / 1000).toString().slice(1);
        addr = addr.replace('-' + dashVal, dashValThousandth);
      }
      regex = new RegExp('^\\d+\\.?\\d*' + scopeName);
      if (regex.test(addr)) {
        switch (i) {
          case 0:
            lane = parseInt(regex.exec(addr).toString().split('巷')[0]) + '';
            break;
          case 1:
            alley = parseInt(regex.exec(addr).toString().split('弄')[0]) + '';
            break;
          case 2:
            noNum = regex.exec(addr).toString().split('號')[0];
        }
        addr = addr.split(regex)[1];
      }
      i++;
    }
    regex = /^\d+-?\d*[Ff樓]/;
    if (regex.test(addr)) {
      regex = /[Ff樓-]/;
      floor = addr.split(regex)[0];
      addr = addr.split(regex)[1];
    }
    addrElement = {
      city: city,
      area: area,
      road: road,
      lane: lane,
      alley: alley,
      no: noNum,
      floor: floor
    };
    return addrElement;
  };

  /*
  將scope資料填入陣列中
  scopePart = scope資料
  scopeArrayName = 巷,弄,號,樓
  scopeEle = 處理過的scope元素
  type = 設定最大最小值或兩者兼有(setMax,setMin,setBoth)
  callback return 
  	1.scopeEle = 處理過的scope元素
  	2.odevity = 處理scope後留下的[單雙連]
  	3.sopeEleNum = 此次處理最小處理到[巷號弄樓](0123),通常用於設定[單雙連]應填入哪個陣列欄位中
  */


  setScopeEle = function(scopePart, scopeArrayName, scopeEle, type, callback) {
    var i, odevity, scopeEleNum, scopeEleReg, scopeEleVal;
    if (/^[單雙連]/.test(scopePart)) {
      odevity = /^[單雙連]/.exec(scopePart).toString();
    }
    scopeEleNum = void 0;
    for (i in scopeArrayName) {
      if (scopePart.match(scopeArrayName[i])) {
        scopeEleReg = new RegExp('\\d+\\.?\\d*' + scopeArrayName[i]);
        scopeEleVal = scopeEleReg.exec(scopePart).toString().replace(scopeArrayName[i], '');
        if (type === 'setBoth') {
          scopeEle[i][1] = scopeEle[i][2] = scopeEleVal;
        } else if (type === 'setMin') {
          scopeEle[i][1] = scopeEleVal;
        } else if (type === 'setMax') {
          scopeEle[i][2] = scopeEleVal;
        }
        scopeEleNum = i;
      }
    }
    return callback(scopeEle, odevity, scopeEleNum);
  };

  /*
  將剩下的地址,區分為road與scope時使用.
  確認剩餘的地址符合scope的規則
  addr = address
  */


  exports.isMatchScopeRule = function(addr) {
    var i, regArray;
    regArray = [/^\d+-?\d*巷\d+弄\d+-?\d*號/, /^\d+-?\d*巷\d+-?\d*[弄號]/, /^\d+弄\d+-?\d*號/, /^\d+-?\d*[號弄巷]/, /^\d+-/];
    i = 0;
    while (i < regArray.length) {
      if (regArray[i].test(addr)) {
        return true;
      }
      i++;
    }
    return false;
  };

  /*
  將大寫數字轉換為小寫數字
  str = 欲轉換字串
  */


  exports.numberFullToHalf = function(str) {
    var i, result;
    result = '';
    if (!str || str === '') {
      return '';
    } else {
      i = 0;
      while (i < str.length) {
        if (str.charCodeAt(i) === 12288) {
          result += " ";
        } else {
          if (str.charCodeAt(i) > 65280 && str.charCodeAt(i) < 65375) {
            result += String.fromCharCode(str.charCodeAt(i) - 65248);
          } else {
            result += String.fromCharCode(str.charCodeAt(i));
          }
        }
        i++;
      }
    }
    return result;
  };

  /*
  將數字轉為國字
  由於地址大多僅處理至十,像是ROAD中的 新北市,石碇區,18重溪,
  故轉換時,需針對兩位的數字針對時去做處理
  str = 欲轉換字串
  */


  exports.numberToChinese = function(str) {
    var chineseNum, dest, i, regex, result, source, strNum;
    result = '';
    chineseNum = '〇一二三四五六七八九'.split('');
    if (!str || str === '') {
      return '';
    } else {
      regex = /\D\d{2}\D|^\d{2}\D|^\d{2}$|\D\d{2}$/;
      while (regex.test(str)) {
        source = regex.exec(str).toString();
        if (/10/.test(source)) {
          dest = source.replace('10', '十');
        } else if (/1\d/.test(source)) {
          dest = source.replace('1', '十');
        } else if (/\d0/.test(source)) {
          dest = source.replace('0', '十');
        } else if (/^\d{2}\D/.test(source)) {
          dest = source.slice(0, 1) + '十' + source.slice(1);
        } else {
          dest = source.slice(0, 2) + '十' + source.slice(2);
        }
        str = str.replace(source, dest);
      }
    }
    i = 0;
    while (i < str.length) {
      if (str.charCodeAt(i) > 47 && str.charCodeAt(i) < 58) {
        strNum = String.fromCharCode(str.charCodeAt(i));
        result += chineseNum[strNum];
      } else {
        result += String.fromCharCode(str.charCodeAt(i));
      }
      i++;
    }
    return result;
  };

  /*
  將國字轉回為數字
  由於地址大多僅處理至十,像是ROAD中的 新北市,石碇區,18重溪,
  故轉換時,需針對兩位的數字針對時去做處理
  str = 欲轉換字串
  */


  exports.chineseToNum = function(str) {
    var regex;
    regex = /[〇ㄧ一二三四五六七八九]/;
    while (regex.test(str)) {
      str = str.replace('〇', '0');
      str = str.replace('一', '1');
      str = str.replace('ㄧ', '1');
      str = str.replace('二', '2');
      str = str.replace('三', '3');
      str = str.replace('四', '4');
      str = str.replace('五', '5');
      str = str.replace('六', '6');
      str = str.replace('七', '7');
      str = str.replace('八', '8');
      str = str.replace('九', '9');
    }
    regex = /十/;
    if (regex.test(str)) {
      while (/\d十\d/.test(str)) {
        str = str.replace('十', '');
      }
      while (/\d十/.test(str)) {
        str = str.replace('十', '0');
      }
      while (/十\d/.test(str)) {
        str = str.replace('十', '1');
      }
      while (/十/.test(str)) {
        str = str.replace('十', '10');
      }
    }
    return str;
  };

  /*
  將字串中的空白去除,將~﹣～之,都轉換為-以利後續判斷
  str = 欲轉換字串
  */


  exports.trimAndReplaceDash = function(str) {
    var regex, seperate;
    regex = /[～﹣ ~]/;
    while (regex.test(str)) {
      str = str.replace(' ', '');
      str = str.replace('～', '-');
      str = str.replace('﹣', '-');
      str = str.replace('~', '-');
    }
    regex = /\d之/;
    while (regex.test(str)) {
      seperate = str.indexOf(regex.exec(str).toString()) + 1;
      str = str.replace(str.substr(seperate, 1), '-');
    }
    return str;
  };

  /*
  取得符合條件的zipData
  zipData = 從資料庫撈出符合city,area,road條件的scope資料
  addrElement = user所輸入地址處理後之元素
  */


  exports.getMatchZipData = function(zipData, addrElement) {
    var i, matchZipData;
    for (i in zipData) {
      if (zipUtility.isInZipDataScope(zipData[i], addrElement)) {
        matchZipData = zipData[i];
      }
    }
    return matchZipData;
  };

  /*
  */


  exports.isInZipDataScope = function(zipData, addrElement) {
    var addrContrast, max, min;
    addrContrast = addrElement.lane || addrElement.alley || addrElement.no;
    if (zipData.laneMin !== '' && zipData.laneMin === zipData.laneMax) {
      if (zipData.laneMin !== addrElement.lane) {
        return false;
      }
      addrContrast = addrElement.alley || addrElement.no;
    }
    if (zipData.alleyMin !== '' && zipData.alleyMin === zipData.alleyMax) {
      if (zipData.alleyMin !== addrElement.alley) {
        return false;
      }
      addrContrast = addrElement.no;
    }
    if (zipData.noMin !== '' && zipData.noMin === zipData.noMax) {
      if (zipData.noMin !== addrElement.no) {
        return false;
      }
      addrContrast = addrElement.floor;
    }
    if (zipData.floorMin !== '' && zipData.floorMin === zipData.floorMax) {
      if (zipData.floorMin !== addrElement.floor) {
        return false;
      }
    }
    min = zipData.laneMin || zipData.alleyMin || zipData.noMin;
    max = zipData.laneMax || zipData.alleyMax || zipData.noMax;
    if (zipData.laneOdevity) {
      return zipUtility.isMatchOdevityAndRange(zipData.laneOdevity, min, max, addrContrast);
    } else if (!(max || min)) {
      return true;
    }
    min = zipData.alleyMin || zipData.noMin;
    max = zipData.alleyMax || zipData.noMax;
    if (zipData.alleyOdevity) {
      return zipUtility.isMatchOdevityAndRange(zipData.alleyOdevity, min, max, addrContrast);
    } else if (!(max || min)) {
      return true;
    }
    min = zipData.noMin;
    max = zipData.noMax;
    if (zipData.noOdevity) {
      return zipUtility.isMatchOdevityAndRange(zipData.noOdevity, min, max, addrContrast);
    } else if (!(max || min)) {
      return true;
    }
    min = zipData.floorMin;
    max = zipData.floorMax;
    if (zipData.floorOdevity) {
      return zipUtility.isMatchOdevityAndRange(zipData.floorOdevity, min, max, addrElement.floor);
    } else if (!(max || min)) {
      return true;
    }
  };

  exports.isMatchOdevityAndRange = function(odevity, min, max, addrElement) {
    var result;
    result = zipUtility.isInRange(min, max, addrElement);
    if (odevity === '全') {
      return true;
    } else if (addrElement == null) {
      return false;
    } else if (odevity === '單') {
      if (parseInt(addrElement) % 2 === 0) {
        return false;
      }
      return result;
    } else if (odevity === '雙') {
      if (parseInt(addrElement) % 2 !== 0) {
        return false;
      }
      return result;
    } else if (odevity === '連') {
      return result;
    }
    return false;
  };

  exports.isInRange = function(min, max, addrElement) {
    if (min !== '') {
      min = parseFloat(min);
    }
    if (max !== '') {
      max = parseFloat(max);
    }
    if (addrElement !== '') {
      addrElement = parseFloat(addrElement);
    }
    if (min === '' && max === '') {
      return true;
    } else if ((addrElement == null) || addrElement === '') {
      return false;
    } else if (min <= addrElement && max >= addrElement) {
      return true;
    } else if (min === '' && max >= addrElement) {
      return true;
    } else if (max === '' && min <= addrElement) {
      return true;
    } else {
      return false;
    }
  };

  /*
  test = () ->
  	i = 0
  	fileData = fs.readFileSync('tmpData/zip5.data','utf8')
  	addrDatas = fileData.split('\n');
  	while i < addrDatas.length - 1
  		addrData = addrDatas[i].split(',')
  		scope = addrData[4]
  		mine.decomposeScope scope, i
  		i++
  	fs.appendFile 'default.txt', logError 
  	fs.appendFile 'log.txt', log 
  	fs.appendFile 'logEle.txt', logEle
  */


}).call(this);
